Oto przyk³ad implementacji klasy Account, która dziedziczy po klasach NormalAccount i SavingAccount, oraz jest w kompozycji z klas¹ Customer:

cpp
Copy code
#include <iostream>
#include <vector>

// Klasa Customer
class Customer {
public:
    Customer(const std::string& name) : name(name) {}

    void addAccount(Account* account) {
        accounts.push_back(account);
    }

    void displayAccounts() const {
        std::cout << "Customer: " << name << std::endl;
        for (const auto& account : accounts) {
            account->display();
        }
    }

private:
    std::string name;
    std::vector<Account*> accounts;
};

// Klasa Account (klasa bazowa)
class Account {
public:
    Account(double balance = 0.0) : balance(balance) {}

    virtual void display() const {
        std::cout << "Account type: Base Account" << std::endl;
        std::cout << "Balance: $" << balance << std::endl;
    }

protected:
    double balance;
};

// Klasa NormalAccount (klasa pochodna)
class NormalAccount : public Account {
public:
    NormalAccount(double balance = 0.0) : Account(balance) {}

    void display() const override {
        std::cout << "Account type: Normal Account" << std::endl;
        std::cout << "Balance: $" << balance << std::endl;
    }
};

// Klasa SavingAccount (klasa pochodna)
class SavingAccount : public Account {
public:
    SavingAccount(double balance = 0.0) : Account(balance) {}

    void display() const override {
        std::cout << "Account type: Saving Account" << std::endl;
        std::cout << "Balance: $" << balance << std::endl;
    }
};

int main() {
    // Tworzenie obiektu klasy Customer
    Customer customer("John Smith");

    // Tworzenie ró¿nych typów kont i dodawanie ich do obiektu klasy Customer
    Account* account1 = new NormalAccount(1000.0);
    Account* account2 = new SavingAccount(5000.0);
    Account* account3 = new NormalAccount(2000.0);

    customer.addAccount(account1);
    customer.addAccount(account2);
    customer.addAccount(account3);

    // Wyœwietlanie kont klienta
    customer.displayAccounts();

    // Zwolnienie pamiêci
    delete account1;
    delete account2;
    delete account3;

    return 0;
}
W powy¿szym przyk³adzie zaimplementowano trzy klasy: Account (klasa bazowa), NormalAccount (klasa pochodna) i SavingAccount (klasa pochodna). Klasa Account posiada pola i metody wspólne dla wszystkich typów kont, natomiast klasy NormalAccount i SavingAccount maj¹ specyficzne implementacje metody display().

Klasa Customer przechowuje informacje o klientach i ich kontach przy u¿yciu kompozycji z klas¹ Account. Klient mo¿e mieæ wiele kont ró¿nego typu, które s¹ przechowywane w wektorze. Metody addAccount() i displayAccounts() umo¿liwiaj¹ dodawanie nowych kont i wyœwietlanie informacji o wszystkich kontach





User
konta s¹ wysy³ane do bazy danych i pobierane z niej
ChatGPT
W przypadku przechowywania kont w bazie danych, mo¿na zastosowaæ odpowiednie zapytania do bazy danych w klasie Customer w metodach addAccount() i displayAccounts(). W poni¿szym przyk³adzie u¿yto prostego interfejsu Database do symulowania operacji na bazie danych:

cpp
Copy code
#include <iostream>
#include <vector>

// Interfejs bazy danych
class Database {
public:
    virtual void saveAccount(const std::string& customerName, const std::string& accountType, double balance) = 0;
    virtual std::vector<std::string> getCustomerAccounts(const std::string& customerName) = 0;
};

// Implementacja bazy danych
class MyDatabase : public Database {
public:
    void saveAccount(const std::string& customerName, const std::string& accountType, double balance) override {
        // Zapis konta do bazy danych
        std::cout << "Saving account: Customer: " << customerName << ", Account Type: " << accountType << ", Balance: $" << balance << std::endl;
    }

    std::vector<std::string> getCustomerAccounts(const std::string& customerName) override {
        // Pobranie kont klienta z bazy danych
        std::cout << "Getting accounts for customer: " << customerName << std::endl;
        // Symulacja zwracania danych z bazy danych
        return { "Normal Account ($1000)", "Saving Account ($5000)", "Normal Account ($2000)" };
    }
};

// Klasa Customer
class Customer {
public:
    Customer(const std::string& name, Database* database) : name(name), database(database) {}

    void addAccount(Account* account) {
        accounts.push_back(account);
        saveAccountToDatabase(account);
    }

    void displayAccounts() const {
        std::cout << "Customer: " << name << std::endl;
        std::vector<std::string> customerAccounts = getCustomerAccountsFromDatabase();
        for (const auto& account : customerAccounts) {
            std::cout << account << std::endl;
        }
    }

private:
    std::string name;
    std::vector<Account*> accounts;
    Database* database;

    void saveAccountToDatabase(Account* account) {
        std::string accountType = typeid(*account).name(); // Pobranie nazwy typu konta
        double balance = account->getBalance();
        database->saveAccount(name, accountType, balance);
    }

    std::vector<std::string> getCustomerAccountsFromDatabase() const {
        return database->getCustomerAccounts(name);
    }
};

// Klasa Account (klasa bazowa)
class Account {
public:
    Account(double balance = 0.0) : balance(balance) {}

    virtual double getBalance() const {
        return balance;
    }

    virtual ~Account() {} // Wirtualny destruktor

    // Pozosta³e metody klasy Account...
};

// Klasa NormalAccount (klasa pochodna)
class NormalAccount : public Account {
public:
    NormalAccount(double balance = 0.0) : Account(balance) {}

    // Pozosta³e metody klasy NormalAccount...
};

// Klasa SavingAccount (klasa pochodna)
class SavingAccount : public Account {
public:
    SavingAccount(double balance = 0.0) : Account(balance) {}

    // Pozosta³e metody klasy SavingAccount...
};

int main() {
    // Tworzenie obiektu klasy Customer